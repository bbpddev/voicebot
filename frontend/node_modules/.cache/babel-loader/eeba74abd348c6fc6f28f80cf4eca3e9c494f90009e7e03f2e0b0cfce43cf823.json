{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef, useState, useCallback } from 'react';\nconst SAMPLE_RATE = 24000;\n\n// AudioWorklet processor code (inline blob)\nconst PROCESSOR_CODE = `\nclass AudioCaptureProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this._buffer = [];\n    this._bufferSize = 1024;\n  }\n  process(inputs) {\n    const channel = inputs[0] && inputs[0][0];\n    if (channel) {\n      for (let i = 0; i < channel.length; i++) this._buffer.push(channel[i]);\n      while (this._buffer.length >= this._bufferSize) {\n        this.port.postMessage(new Float32Array(this._buffer.splice(0, this._bufferSize)));\n      }\n    }\n    return true;\n  }\n}\nregisterProcessor('audio-capture', AudioCaptureProcessor);\n`;\nfunction float32ToInt16Base64(float32) {\n  const int16 = new Int16Array(float32.length);\n  for (let i = 0; i < float32.length; i++) {\n    int16[i] = Math.min(1, Math.max(-1, float32[i])) * 32767;\n  }\n  const bytes = new Uint8Array(int16.buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);\n  return btoa(binary);\n}\nfunction base64ToFloat32(b64) {\n  const binaryStr = atob(b64);\n  const bytes = new Uint8Array(binaryStr.length);\n  for (let i = 0; i < binaryStr.length; i++) bytes[i] = binaryStr.charCodeAt(i);\n  const int16 = new Int16Array(bytes.buffer);\n  const float32 = new Float32Array(int16.length);\n  for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;\n  return float32;\n}\nexport function useVoiceAgent({\n  onTicketsChange\n} = {}) {\n  _s();\n  const [status, setStatus] = useState('idle');\n  const [transcript, setTranscript] = useState([]);\n  const [currentAiText, setCurrentAiText] = useState('');\n  const [lastFunction, setLastFunction] = useState(null);\n  const [error, setError] = useState(null);\n  const wsRef = useRef(null);\n  const audioCtxRef = useRef(null);\n  const playbackCtxRef = useRef(null);\n  const streamRef = useRef(null);\n  const workletRef = useRef(null);\n  const workletBlobRef = useRef(null);\n  const nextPlayTimeRef = useRef(0);\n  const aiTextRef = useRef('');\n  const statusRef = useRef('idle');\n  const updateStatus = useCallback(s => {\n    statusRef.current = s;\n    setStatus(s);\n  }, []);\n  const playAudioChunk = useCallback(b64Audio => {\n    if (!playbackCtxRef.current) return;\n    try {\n      const ctx = playbackCtxRef.current;\n      if (ctx.state === 'suspended') ctx.resume();\n      const float32 = base64ToFloat32(b64Audio);\n      const buffer = ctx.createBuffer(1, float32.length, SAMPLE_RATE);\n      buffer.copyToChannel(float32, 0);\n      const source = ctx.createBufferSource();\n      source.buffer = buffer;\n      source.connect(ctx.destination);\n      const now = ctx.currentTime;\n      const startTime = Math.max(now + 0.02, nextPlayTimeRef.current);\n      source.start(startTime);\n      nextPlayTimeRef.current = startTime + buffer.duration;\n    } catch (e) {\n      // ignore playback errors\n    }\n  }, []);\n  const getWsUrl = () => {\n    const base = process.env.REACT_APP_BACKEND_URL || window.location.origin;\n    return base.replace('https://', 'wss://').replace('http://', 'ws://') + '/api/ws';\n  };\n  const connect = useCallback(async () => {\n    if (statusRef.current !== 'idle' && statusRef.current !== 'error') return;\n    setError(null);\n    updateStatus('connecting');\n    setTranscript([]);\n    aiTextRef.current = '';\n    try {\n      // Audio contexts\n      audioCtxRef.current = new AudioContext({\n        sampleRate: SAMPLE_RATE\n      });\n      playbackCtxRef.current = new AudioContext({\n        sampleRate: SAMPLE_RATE\n      });\n      nextPlayTimeRef.current = 0;\n\n      // Connect WebSocket\n      const ws = new WebSocket(getWsUrl());\n      wsRef.current = ws;\n      ws.onopen = async () => {\n        updateStatus('active');\n        await startMicCapture(ws);\n      };\n      ws.onerror = () => {\n        setError('Connection failed. Check your API keys and try again.');\n        updateStatus('error');\n      };\n      ws.onclose = () => {\n        if (statusRef.current !== 'idle') {\n          updateStatus('idle');\n        }\n        stopMicCapture();\n      };\n      ws.onmessage = evt => {\n        try {\n          const data = JSON.parse(evt.data);\n          handleEvent(data);\n        } catch (e) {}\n      };\n    } catch (e) {\n      setError('Could not initialize audio. Please allow microphone access.');\n      updateStatus('error');\n    }\n  }, []); // eslint-disable-line\n\n  const handleEvent = event => {\n    switch (event.type) {\n      case 'session.updated':\n        updateStatus('active');\n        break;\n      case 'input_audio_buffer.speech_started':\n        if (statusRef.current === 'speaking') {\n          // User interrupted\n          nextPlayTimeRef.current = 0;\n        }\n        updateStatus('listening');\n        break;\n      case 'input_audio_buffer.speech_stopped':\n        updateStatus('processing');\n        break;\n      case 'response.created':\n        updateStatus('speaking');\n        aiTextRef.current = '';\n        setCurrentAiText('');\n        break;\n      case 'response.output_audio.delta':\n        if (event.delta) playAudioChunk(event.delta);\n        break;\n      case 'response.output_audio_transcript.delta':\n        aiTextRef.current += event.delta || '';\n        setCurrentAiText(aiTextRef.current);\n        break;\n      case 'response.output_audio_transcript.done':\n        if (aiTextRef.current.trim()) {\n          setTranscript(prev => [...prev, {\n            role: 'assistant',\n            text: aiTextRef.current,\n            time: Date.now()\n          }]);\n        }\n        aiTextRef.current = '';\n        setCurrentAiText('');\n        updateStatus('active');\n        break;\n      case 'conversation.item.input_audio_transcription.completed':\n        if (event.transcript) {\n          setTranscript(prev => [...prev, {\n            role: 'user',\n            text: event.transcript,\n            time: Date.now()\n          }]);\n        }\n        break;\n      case 'function.started':\n        // Add a \"thinking\" function entry to the transcript\n        setTranscript(prev => [...prev, {\n          role: 'function',\n          name: event.function,\n          status: 'pending',\n          time: Date.now(),\n          id: Date.now()\n        }]);\n        updateStatus('processing');\n        break;\n      case 'function.executed':\n        // Replace the pending function entry with the completed result\n        setTranscript(prev => {\n          const idx = [...prev].reverse().findIndex(m => m.role === 'function' && m.name === event.function && m.status === 'pending');\n          if (idx === -1) {\n            return [...prev, {\n              role: 'function',\n              name: event.function,\n              args: event.args,\n              result: event.result,\n              status: 'done',\n              time: Date.now(),\n              id: Date.now()\n            }];\n          }\n          const realIdx = prev.length - 1 - idx;\n          const updated = [...prev];\n          updated[realIdx] = {\n            ...updated[realIdx],\n            args: event.args,\n            result: event.result,\n            status: 'done'\n          };\n          return updated;\n        });\n        setLastFunction({\n          name: event.function,\n          result: event.result,\n          args: event.args\n        });\n        if (event.function === 'create_ticket' || event.function === 'update_ticket_status') {\n          onTicketsChange && onTicketsChange();\n        }\n        updateStatus('speaking');\n        break;\n      case 'response.done':\n        // Fallback: commit any streamed text that wasn't committed by transcript.done\n        if (aiTextRef.current.trim()) {\n          setTranscript(prev => [...prev, {\n            role: 'assistant',\n            text: aiTextRef.current,\n            time: Date.now()\n          }]);\n          aiTextRef.current = '';\n          setCurrentAiText('');\n        }\n        if (statusRef.current !== 'idle') updateStatus('active');\n        break;\n      case 'error':\n        setError(event.message || 'An error occurred');\n        updateStatus('error');\n        break;\n      default:\n        break;\n    }\n  };\n  const startMicCapture = async ws => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: SAMPLE_RATE,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true\n        }\n      });\n      streamRef.current = stream;\n      const ctx = audioCtxRef.current;\n      if (ctx.state === 'suspended') await ctx.resume();\n\n      // AudioWorklet\n      const blob = new Blob([PROCESSOR_CODE], {\n        type: 'application/javascript'\n      });\n      const blobUrl = URL.createObjectURL(blob);\n      workletBlobRef.current = blobUrl;\n      await ctx.audioWorklet.addModule(blobUrl);\n      const source = ctx.createMediaStreamSource(stream);\n      const worklet = new AudioWorkletNode(ctx, 'audio-capture');\n      workletRef.current = worklet;\n      worklet.port.onmessage = e => {\n        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;\n        const b64 = float32ToInt16Base64(e.data);\n        wsRef.current.send(JSON.stringify({\n          type: 'input_audio_buffer.append',\n          audio: b64\n        }));\n      };\n      source.connect(worklet);\n    } catch (e) {\n      // Close the WebSocket cleanly when mic fails\n      if (ws && ws.readyState === WebSocket.OPEN) ws.close();\n      wsRef.current = null;\n      stopMicCapture();\n\n      // Detect iframe microphone restriction\n      const inIframe = window !== window.top;\n      if (inIframe) {\n        setError('IFRAME_MIC_BLOCKED');\n      } else {\n        setError('Microphone access denied. Please allow microphone access in your browser and try again.');\n      }\n      updateStatus('error');\n    }\n  };\n  const stopMicCapture = () => {\n    if (workletRef.current) {\n      try {\n        workletRef.current.disconnect();\n      } catch (e) {}\n      workletRef.current = null;\n    }\n    if (workletBlobRef.current) {\n      URL.revokeObjectURL(workletBlobRef.current);\n      workletBlobRef.current = null;\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(t => t.stop());\n      streamRef.current = null;\n    }\n    if (audioCtxRef.current) {\n      try {\n        audioCtxRef.current.close();\n      } catch (e) {}\n      audioCtxRef.current = null;\n    }\n    if (playbackCtxRef.current) {\n      try {\n        playbackCtxRef.current.close();\n      } catch (e) {}\n      playbackCtxRef.current = null;\n    }\n    nextPlayTimeRef.current = 0;\n  };\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    stopMicCapture();\n    updateStatus('idle');\n    aiTextRef.current = '';\n    setCurrentAiText('');\n  }, []); // eslint-disable-line\n\n  return {\n    status,\n    transcript,\n    currentAiText,\n    lastFunction,\n    error,\n    connect,\n    disconnect\n  };\n}\n_s(useVoiceAgent, \"uHbJYw786GFmNMhXURqTCJb4qUI=\");","map":{"version":3,"names":["useRef","useState","useCallback","SAMPLE_RATE","PROCESSOR_CODE","float32ToInt16Base64","float32","int16","Int16Array","length","i","Math","min","max","bytes","Uint8Array","buffer","binary","String","fromCharCode","btoa","base64ToFloat32","b64","binaryStr","atob","charCodeAt","Float32Array","useVoiceAgent","onTicketsChange","_s","status","setStatus","transcript","setTranscript","currentAiText","setCurrentAiText","lastFunction","setLastFunction","error","setError","wsRef","audioCtxRef","playbackCtxRef","streamRef","workletRef","workletBlobRef","nextPlayTimeRef","aiTextRef","statusRef","updateStatus","s","current","playAudioChunk","b64Audio","ctx","state","resume","createBuffer","copyToChannel","source","createBufferSource","connect","destination","now","currentTime","startTime","start","duration","e","getWsUrl","base","process","env","REACT_APP_BACKEND_URL","window","location","origin","replace","AudioContext","sampleRate","ws","WebSocket","onopen","startMicCapture","onerror","onclose","stopMicCapture","onmessage","evt","data","JSON","parse","handleEvent","event","type","delta","trim","prev","role","text","time","Date","name","function","id","idx","reverse","findIndex","m","args","result","realIdx","updated","message","stream","navigator","mediaDevices","getUserMedia","audio","channelCount","echoCancellation","noiseSuppression","blob","Blob","blobUrl","URL","createObjectURL","audioWorklet","addModule","createMediaStreamSource","worklet","AudioWorkletNode","port","readyState","OPEN","send","stringify","close","inIframe","top","disconnect","revokeObjectURL","getTracks","forEach","t","stop"],"sources":["/app/frontend/src/hooks/useVoiceAgent.js"],"sourcesContent":["import { useRef, useState, useCallback } from 'react';\n\nconst SAMPLE_RATE = 24000;\n\n// AudioWorklet processor code (inline blob)\nconst PROCESSOR_CODE = `\nclass AudioCaptureProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this._buffer = [];\n    this._bufferSize = 1024;\n  }\n  process(inputs) {\n    const channel = inputs[0] && inputs[0][0];\n    if (channel) {\n      for (let i = 0; i < channel.length; i++) this._buffer.push(channel[i]);\n      while (this._buffer.length >= this._bufferSize) {\n        this.port.postMessage(new Float32Array(this._buffer.splice(0, this._bufferSize)));\n      }\n    }\n    return true;\n  }\n}\nregisterProcessor('audio-capture', AudioCaptureProcessor);\n`;\n\nfunction float32ToInt16Base64(float32) {\n  const int16 = new Int16Array(float32.length);\n  for (let i = 0; i < float32.length; i++) {\n    int16[i] = Math.min(1, Math.max(-1, float32[i])) * 32767;\n  }\n  const bytes = new Uint8Array(int16.buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);\n  return btoa(binary);\n}\n\nfunction base64ToFloat32(b64) {\n  const binaryStr = atob(b64);\n  const bytes = new Uint8Array(binaryStr.length);\n  for (let i = 0; i < binaryStr.length; i++) bytes[i] = binaryStr.charCodeAt(i);\n  const int16 = new Int16Array(bytes.buffer);\n  const float32 = new Float32Array(int16.length);\n  for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;\n  return float32;\n}\n\nexport function useVoiceAgent({ onTicketsChange } = {}) {\n  const [status, setStatus] = useState('idle');\n  const [transcript, setTranscript] = useState([]);\n  const [currentAiText, setCurrentAiText] = useState('');\n  const [lastFunction, setLastFunction] = useState(null);\n  const [error, setError] = useState(null);\n\n  const wsRef = useRef(null);\n  const audioCtxRef = useRef(null);\n  const playbackCtxRef = useRef(null);\n  const streamRef = useRef(null);\n  const workletRef = useRef(null);\n  const workletBlobRef = useRef(null);\n  const nextPlayTimeRef = useRef(0);\n  const aiTextRef = useRef('');\n  const statusRef = useRef('idle');\n\n  const updateStatus = useCallback((s) => {\n    statusRef.current = s;\n    setStatus(s);\n  }, []);\n\n  const playAudioChunk = useCallback((b64Audio) => {\n    if (!playbackCtxRef.current) return;\n    try {\n      const ctx = playbackCtxRef.current;\n      if (ctx.state === 'suspended') ctx.resume();\n      const float32 = base64ToFloat32(b64Audio);\n      const buffer = ctx.createBuffer(1, float32.length, SAMPLE_RATE);\n      buffer.copyToChannel(float32, 0);\n      const source = ctx.createBufferSource();\n      source.buffer = buffer;\n      source.connect(ctx.destination);\n      const now = ctx.currentTime;\n      const startTime = Math.max(now + 0.02, nextPlayTimeRef.current);\n      source.start(startTime);\n      nextPlayTimeRef.current = startTime + buffer.duration;\n    } catch (e) {\n      // ignore playback errors\n    }\n  }, []);\n\n  const getWsUrl = () => {\n    const base = process.env.REACT_APP_BACKEND_URL || window.location.origin;\n    return base.replace('https://', 'wss://').replace('http://', 'ws://') + '/api/ws';\n  };\n\n  const connect = useCallback(async () => {\n    if (statusRef.current !== 'idle' && statusRef.current !== 'error') return;\n    setError(null);\n    updateStatus('connecting');\n    setTranscript([]);\n    aiTextRef.current = '';\n\n    try {\n      // Audio contexts\n      audioCtxRef.current = new AudioContext({ sampleRate: SAMPLE_RATE });\n      playbackCtxRef.current = new AudioContext({ sampleRate: SAMPLE_RATE });\n      nextPlayTimeRef.current = 0;\n\n      // Connect WebSocket\n      const ws = new WebSocket(getWsUrl());\n      wsRef.current = ws;\n\n      ws.onopen = async () => {\n        updateStatus('active');\n        await startMicCapture(ws);\n      };\n\n      ws.onerror = () => {\n        setError('Connection failed. Check your API keys and try again.');\n        updateStatus('error');\n      };\n\n      ws.onclose = () => {\n        if (statusRef.current !== 'idle') {\n          updateStatus('idle');\n        }\n        stopMicCapture();\n      };\n\n      ws.onmessage = (evt) => {\n        try {\n          const data = JSON.parse(evt.data);\n          handleEvent(data);\n        } catch (e) {}\n      };\n    } catch (e) {\n      setError('Could not initialize audio. Please allow microphone access.');\n      updateStatus('error');\n    }\n  }, []); // eslint-disable-line\n\n  const handleEvent = (event) => {\n    switch (event.type) {\n      case 'session.updated':\n        updateStatus('active');\n        break;\n      case 'input_audio_buffer.speech_started':\n        if (statusRef.current === 'speaking') {\n          // User interrupted\n          nextPlayTimeRef.current = 0;\n        }\n        updateStatus('listening');\n        break;\n      case 'input_audio_buffer.speech_stopped':\n        updateStatus('processing');\n        break;\n      case 'response.created':\n        updateStatus('speaking');\n        aiTextRef.current = '';\n        setCurrentAiText('');\n        break;\n      case 'response.output_audio.delta':\n        if (event.delta) playAudioChunk(event.delta);\n        break;\n      case 'response.output_audio_transcript.delta':\n        aiTextRef.current += event.delta || '';\n        setCurrentAiText(aiTextRef.current);\n        break;\n      case 'response.output_audio_transcript.done':\n        if (aiTextRef.current.trim()) {\n          setTranscript(prev => [\n            ...prev,\n            { role: 'assistant', text: aiTextRef.current, time: Date.now() },\n          ]);\n        }\n        aiTextRef.current = '';\n        setCurrentAiText('');\n        updateStatus('active');\n        break;\n      case 'conversation.item.input_audio_transcription.completed':\n        if (event.transcript) {\n          setTranscript(prev => [\n            ...prev,\n            { role: 'user', text: event.transcript, time: Date.now() },\n          ]);\n        }\n        break;\n      case 'function.started':\n        // Add a \"thinking\" function entry to the transcript\n        setTranscript(prev => [\n          ...prev,\n          { role: 'function', name: event.function, status: 'pending', time: Date.now(), id: Date.now() },\n        ]);\n        updateStatus('processing');\n        break;\n      case 'function.executed':\n        // Replace the pending function entry with the completed result\n        setTranscript(prev => {\n          const idx = [...prev].reverse().findIndex(m => m.role === 'function' && m.name === event.function && m.status === 'pending');\n          if (idx === -1) {\n            return [...prev, { role: 'function', name: event.function, args: event.args, result: event.result, status: 'done', time: Date.now(), id: Date.now() }];\n          }\n          const realIdx = prev.length - 1 - idx;\n          const updated = [...prev];\n          updated[realIdx] = { ...updated[realIdx], args: event.args, result: event.result, status: 'done' };\n          return updated;\n        });\n        setLastFunction({ name: event.function, result: event.result, args: event.args });\n        if (event.function === 'create_ticket' || event.function === 'update_ticket_status') {\n          onTicketsChange && onTicketsChange();\n        }\n        updateStatus('speaking');\n        break;\n      case 'response.done':\n        // Fallback: commit any streamed text that wasn't committed by transcript.done\n        if (aiTextRef.current.trim()) {\n          setTranscript(prev => [\n            ...prev,\n            { role: 'assistant', text: aiTextRef.current, time: Date.now() },\n          ]);\n          aiTextRef.current = '';\n          setCurrentAiText('');\n        }\n        if (statusRef.current !== 'idle') updateStatus('active');\n        break;\n      case 'error':\n        setError(event.message || 'An error occurred');\n        updateStatus('error');\n        break;\n      default:\n        break;\n    }\n  };\n\n  const startMicCapture = async (ws) => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: { sampleRate: SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true },\n      });\n      streamRef.current = stream;\n      const ctx = audioCtxRef.current;\n      if (ctx.state === 'suspended') await ctx.resume();\n\n      // AudioWorklet\n      const blob = new Blob([PROCESSOR_CODE], { type: 'application/javascript' });\n      const blobUrl = URL.createObjectURL(blob);\n      workletBlobRef.current = blobUrl;\n      await ctx.audioWorklet.addModule(blobUrl);\n\n      const source = ctx.createMediaStreamSource(stream);\n      const worklet = new AudioWorkletNode(ctx, 'audio-capture');\n      workletRef.current = worklet;\n\n      worklet.port.onmessage = (e) => {\n        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;\n        const b64 = float32ToInt16Base64(e.data);\n        wsRef.current.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: b64 }));\n      };\n\n      source.connect(worklet);\n    } catch (e) {\n      // Close the WebSocket cleanly when mic fails\n      if (ws && ws.readyState === WebSocket.OPEN) ws.close();\n      wsRef.current = null;\n      stopMicCapture();\n\n      // Detect iframe microphone restriction\n      const inIframe = window !== window.top;\n      if (inIframe) {\n        setError('IFRAME_MIC_BLOCKED');\n      } else {\n        setError('Microphone access denied. Please allow microphone access in your browser and try again.');\n      }\n      updateStatus('error');\n    }\n  };\n\n  const stopMicCapture = () => {\n    if (workletRef.current) {\n      try { workletRef.current.disconnect(); } catch (e) {}\n      workletRef.current = null;\n    }\n    if (workletBlobRef.current) {\n      URL.revokeObjectURL(workletBlobRef.current);\n      workletBlobRef.current = null;\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(t => t.stop());\n      streamRef.current = null;\n    }\n    if (audioCtxRef.current) {\n      try { audioCtxRef.current.close(); } catch (e) {}\n      audioCtxRef.current = null;\n    }\n    if (playbackCtxRef.current) {\n      try { playbackCtxRef.current.close(); } catch (e) {}\n      playbackCtxRef.current = null;\n    }\n    nextPlayTimeRef.current = 0;\n  };\n\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    stopMicCapture();\n    updateStatus('idle');\n    aiTextRef.current = '';\n    setCurrentAiText('');\n  }, []); // eslint-disable-line\n\n  return {\n    status,\n    transcript,\n    currentAiText,\n    lastFunction,\n    error,\n    connect,\n    disconnect,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}